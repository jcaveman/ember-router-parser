'use strict';

var esprima = require('esprima');

/**
 * Given the path to a router will parse it and object with the routes
 * @param {string} router - Path to the router we want to parse
 * @returns {object} routes - Object containing the routes in this format:
 *  {
 *    "routeName": {
 *      path: "some/:path/here"
 *    },
 *    ...
 *  }
 */
function getRoutesFromRouter() {

}

/**
 * Parses a router and returns object with the routes
 * @param {string} router - Router code to be parsed
 * @returns {object} routes - Object containing the routes in this format:
 *  {
 *    "routeName": {
 *      path: "some/:path/here"
 *    },
 *    ...
 *  }
 */
function parseRouter(router) {
  var ast = esprima.parse(router);
  ast = exports.getRouterMapBody(ast);

  if (!ast || ast.type !== 'BlockStatement') {
    return null;
  }

  var routes = {};

  var current;
  var type;
  for (var i = 0; i < ast.body.length; i++) {
    current = ast.body[i];
    if (current.type === 'ExpressionStatement') {
      type = current.expression.callee.property.name;
      switch (type) {
        case 'route':
          exports.addRoute(current, routes);
          break;
        case 'resource':
          break;
        default:
      }
    }
  }

  return routes;
}

/**
 * Parses an ExpressionStatement representing a route and adds it to the routes
 * object
 * @param {object} expressionStatement - ExpressionStatement parsed by esprima
 * @param {object} routes - Object where the route will be added
 */
function addRoute(expressionStatement, routes) {
  var args = expressionStatement.expression.arguments,
      i,
      property,
      newRoute;

  if (args.length > 1) {
    for (i in args[1].properties) {
      property = args[1].properties[i];
      if (property.key.name === 'path') {
        newRoute = {
          path: property.value.value
        };
        break;
      }
    }
  } else {
    newRoute = {
      path: '/' + args[0].value
    };
  }

  routes[args[0].value] = newRoute;
}

/**
 * Given a router AST it will return the part the FunctionExpression that
 * corresponds to the function passed to App.Router.map
 * @param {object} ast - AST generated by running esprima on the router
 * @returns {object} The CallExpression that was called by App.Router.map
 */
function getRouterMapBody(ast) {
  var callExpression = exports.findInAst('CallExpression', ast);
  if (callExpression && callExpression.callee &&
      callExpression.callee.property &&
      callExpression.callee.property.name === 'map') {
    return callExpression['arguments'][0].body;
  }
}

/**
 * Finds the first occurrence of needle inside of the given ast
 * @param {string} needle - Expression we are looking for
 * @param {object} haystack - AST where we will search
 * @returns {object} found - The first object found with the type specified in
 *          then needle
 */
function findInAst(needle, haystack) {
  if (typeof haystack !== 'object') {
    return null;
  }

  if (haystack.type === needle) {
    return haystack;
  }

  var i,
      found;
  for (i in haystack) {
    if (typeof haystack[i] === 'object') {
      found = exports.findInAst(needle, haystack[i]);
      if (found) {
        return found;
      }
    }
  }

  return null;
}

exports.getRoutesFromRouter = getRoutesFromRouter;
exports.parseRouter = parseRouter;
exports.addRoute = addRoute;
exports.getRouterMapBody = getRouterMapBody;
exports.findInAst = findInAst;
