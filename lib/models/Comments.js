'use strict';

/**
 * String that identifies an anotation as a parameter
 * @type {string}
 */
var PARAM = 'param';

/**
 * Constructor for Comments model
 * @param {object} comments - Comments from AST generated by esprima (using the
 *        comment and loc options)
 */
function Comments(comments) {
  this.format(comments);
}

/**
 * Object representing the comments . The format of the object will be:
 * {
 *   <index>: <commentObject>,
 *   ...
 * }
 * Where <index> is a number representing loc.end.line for this comment
 * and <commentObject> is an object as returned by this.parse
 * @type {object} hash with comments
 */
Comments.prototype.comments = {};

/**
 * Grabs comments array from AST and transforms it into this.comments format
 * @param {array} comments - Comments array from esprima
 */
Comments.prototype.format = function(comments) {
  this.comments = {};

  if (!comments) {
    return;
  }

  for (var i = 0; i < comments.length; i++) {
    this.comments[comments[i].loc.end.line] = this.parse(comments[i].value);
  }
};

/**
 * Parses a comment and divides it into the main comment and the annotations'
 * comments
 * @param {string} comment
 * @returns {object} commentObject
 *   {
 *     main: <mainComment>,
 *     params: {
 *       <param>: <value>
 *     }
 *     annotations: {
 *       <annotation>: <value>
 *     }
 *   }
 * <mainComment> Is the part of the comment that is before any annotations
 * <annotation> Is a key for an annotation, for example: documentUrl
 * <value> is the value of the comment between the annotation and the next
 * annotation or the end of the comment.
 */
Comments.prototype.parse = function(comment) {
  var commentObject = {
    annotations: {},
    params: {}
  };

  comment = comment
    // Replaces all * with an empty string
    .replace(/\*/g, '')
    // Replaces all line breaks with spaces
    .replace(/\n/g, ' ')
    // Replaces multiple spaces with a single space
    .replace(/\s{2,}/g, ' ');

  var parts = comment.split('@');

  commentObject.main = parts[0].trim();

  var firstSpace = 0;
  var param = [];
  var annotation;
  for (var i = 1; i < parts.length; i++) {
    firstSpace = parts[i].indexOf(' ');
    if (firstSpace === -1) {
      annotation = parts[i];
    } else {
      annotation = parts[i].substring(0, firstSpace);
    }

    if (annotation === PARAM) {
      param = this.parseParam(parts[i]);
      commentObject.params[param[0]] = param[1];
    } else {
      commentObject.annotations[annotation] =
          parts[i].substring(firstSpace).trim();
    }
  }

  return commentObject;
};

/**
 * Parses a parameter from a string in this form:
 * "param param_name Parameter description"
 * to this form:
 * [param_name, 'Parameter description']
 * @param {string} annotation
 * @returns {array} parsed
 */
Comments.prototype.parseParam = function(annotation) {
  var firstSpace = annotation.indexOf(' ');
  var secondSpace = annotation.indexOf(' ', firstSpace + 1);
  var parsed = [
    annotation.substring(firstSpace, secondSpace).trim(),
    annotation.substring(secondSpace).trim()
  ];

  return parsed;
};

/**
 * Checks if this route should be documented based on annotations
 * @param {object} expression - ExpressionStatement parsed by esprima
 * @returns {boolean} Returns true if this expression should be documented
 */
Comments.prototype.shouldDocumentRoute = function(expression) {
  var current = this.getExpressionComment(expression);

  if (!current.params) {
    return false;
  }

  if (current.annotations.documentUrl === undefined) {
    return false;
  }

  return true;
};

/**
 * Returns a commentObject for the given expression (as created by this.parse)
 * @param {object} expression - ExpressionStatement parsed by esprima
 * @returns {object} commentObject
 */
Comments.prototype.getExpressionComment = function(expression) {
  var commentIndex = expression.loc.start.line - 1;
  return this.comments[commentIndex] || {};
};

module.exports = Comments;
